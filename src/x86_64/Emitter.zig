pub const std = @import("std");
const as = @import("asm.zig");

writer: *Writer,

const Emitter = @This();

const Writer = std.Io.Writer;
const Error = Writer.Error;

pub fn emit(p: as.Program, writer: *Writer) Error!void {
    var self: Emitter = .{ .writer = writer };
    try self.program(p);
    try self.writer.flush();
}

fn program(self: Emitter, p: as.Program) Error!void {
    try self.writeLine("// this file is autogenerated by zcc compiler");

    try self.writeLine(".section .text");

    try self.subroutine(p.main_subroutine);

    try self.writeLine(".section .note.GNU-stack,\"\",@progbits");
}

fn subroutine(self: Emitter, s: as.Subroutine) Error!void {
    try self.printLine(
        \\.global {s}
        \\{s}:
    , .{ s.name, s.name });
    try self.writeLine(
        \\pushq %rbp
        \\movq %rsp, %rbp
    );
    for (s.instructions) |instr| {
        try self.instruction(instr);
    }
}

fn instruction(self: Emitter, instr: as.Instruction) Error!void {
    switch (instr) {
        .allocate_stack => |size| try self.printLine("subq ${}, %rsp", .{size}),
        .cdq => try self.writeLine("cdq"),
        .ret => try self.writeLine(
            \\movq %rbp, %rsp
            \\popq %rbp
            \\ret
        ),
        .mov => |mov| try self.printLine("movl {f}, {f}", .{
            operand(mov.src),
            operand(mov.dst),
        }),
        .idiv => |div| try self.printLine("idivl {f}", .{operand(div)}),
        .unary => |unary| try self.printLine("{s}l {f}", .{
            @tagName(unary.operator),
            operand(unary.operand),
        }),
        .binary => |binary| try self.printLine("{s}l {f}, {f}", .{
            @tagName(binary.operator),
            operand(binary.src1),
            operand(binary.src2),
        }),
        .cmp => |cmp| try self.printLine("cmpl {f}, {f}", .{
            operand(cmp.src1),
            operand(cmp.src2),
        }),
        .jmp => |target| try self.printLine("jmp .L{s}", .{target}),
        .label => |label| try self.printLine(".L{s}:", .{label}),
        .jmp_cc => |jump| try self.printLine("j{s} .L{s}", .{
            @tagName(jump.cond_code),
            jump.target,
        }),
        .set_cc => |set| try self.printLine("set{s} {f}", .{
            @tagName(set.cond_code),
            operand(set.dst),
        }),
    }
}

fn operandFmt(self: as.Operand, writer: *Writer) Error!void {
    switch (self) {
        .imm => |val| try writer.print("${}", .{val}),
        .reg => |reg| try writer.print("%{s}", .{reg.name()}),
        .stack => |stack| try writer.print("{}(%rbp)", .{stack}),
        .pseudo => unreachable,
    }
}

fn operand(op: as.Operand) std.fmt.Alt(as.Operand, operandFmt) {
    return .{ .data = op };
}

fn writeLine(self: Emitter, l: []const u8) Error!void {
    try self.writer.writeAll(l);
    try self.newLine();
}

fn newLine(self: Emitter) Error!void {
    try self.writer.writeByte('\n');
}

fn printLine(self: Emitter, comptime fmt: []const u8, args: anytype) Error!void {
    try self.writer.print(fmt, args);
    try self.newLine();
}
